#
# This file is part of gstreamerD.
#
# gstreamerD is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License
# as published by the Free Software Foundation; either version 3
# of the License, or (at your option) any later version, with
# some exceptions, please read the COPYING file.
#
# gstreamerD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with gstreamerD; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110, USA
#


#
###
#####
# Definitions for wrapping GStreamer
#####
###
#

enumType: GST_ELEMENT_FLAG_LAST GstElementFlags.FLAG_LAST
enumType: GST_OBJECT_FLAG_LAST GstObjectFlags.FLAG_LAST
enumType: GST_MINI_OBJECT_FLAG_READONLY GstMiniObjectFlags.READONLY
enumType: GST_MINI_OBJECT_FLAG_LAST GstMiniObjectFlags.LAST
enumType: GST_STATE_NULL GstState.NULL
enumType: GST_STATE_READY GstState.READY
enumType: GST_STATE_PAUSED GstState.PAUSED
enumType: GST_STATE_PLAYING GstState.PLAYING
enumType: FLAG_LAST GstBinFlags.FLAG_LAST

alias: GST_SEEK_TYPE_NONE NONE
alias: GST_SEEK_TYPE_CUR CUR
alias: GST_SEEK_TYPE_SET SET
alias: GST_SEEK_TYPE_END END
alias: GST_BIN_FLAG_LAST FLAG_LAST

alias: GStaticRecMutex void
alias: GstXmlNodePtr void*
alias: xmlNodePtr void*

addTypedefs: start
public import gtkc.glibtypes;
public import gtkc.gthreadtypes;
public import gtkc.gobjecttypes;
addTypedefs: end

addAliases: start
	alias void GStaticRecMutex;
	alias void* GstXmlNodePtr;
	alias void* xmlNodePtr;
addAliases: end

addEnums: start
	/**
	 * GstEventTypeFlags indicate the aspects of the different GstEventType
	 * values. You can get the type flags of a GstEventType with the
	 * gst_event_type_get_flags() function.
	 * GST_EVENT_TYPE_UPSTREAM
	 */
	public enum GstEventTypeFlags
	{
		UPSTREAM     = 1 << 0,
		DOWNSTREAM   = 1 << 1,
		SERIALIZED   = 1 << 2,
		STICKY       = 1 << 3,
		STICKY_MULTI = 1 << 4.
	}
	alias GstEventTypeFlags EventTypeFlags;

	/**
	 * GstEventType lists the standard event types that can be sent in a pipeline.
	 * The custom event types can be used for private messages between elements
	 * that can't be expressed using normal
	 * GStreamer buffer passing semantics. Custom events carry an arbitrary
	 * GstStructure.
	 * Specific custom events are distinguished by the name of the structure.
	 * GST_EVENT_UNKNOWN
	 */
	public enum GstEventType
	{
		UNKNOWN = 0,

		/+* bidirectional events +/
		FLUSH_START = (10 << 8) | GstEventTypeFlags.UPSTREAM | GstEventTypeFlags.DOWNSTREAM,
		FLUSH_STOP  = (20 << 8) | GstEventTypeFlags.UPSTREAM | GstEventTypeFlags.DOWNSTREAM | GstEventTypeFlags.SERIALIZED,

		/+* downstream serialized events +/
		STREAM_START = (  40 << 8 ) | GstEventTypeFlags.DOWNSTREAM | GstEventTypeFlags.SERIALIZED | GstEventTypeFlags.STICKY,
		CAPS         = (  50 << 8 ) | GstEventTypeFlags.DOWNSTREAM | GstEventTypeFlags.SERIALIZED | GstEventTypeFlags.STICKY,
		SEGMENT      = (  70 << 8 ) | GstEventTypeFlags.DOWNSTREAM | GstEventTypeFlags.SERIALIZED | GstEventTypeFlags.STICKY,
		TAG          = (  80 << 8 ) | GstEventTypeFlags.DOWNSTREAM | GstEventTypeFlags.SERIALIZED | GstEventTypeFlags.STICKY | GstEventTypeFlags.STICKY_MULTI,
		BUFFERSIZE   = (  90 << 8 ) | GstEventTypeFlags.DOWNSTREAM | GstEventTypeFlags.SERIALIZED | GstEventTypeFlags.STICKY,
		SINK_MESSAGE = ( 100 << 8 ) | GstEventTypeFlags.DOWNSTREAM | GstEventTypeFlags.SERIALIZED | GstEventTypeFlags.STICKY | GstEventTypeFlags.STICKY_MULTI,
		EOS          = ( 110 << 8 ) | GstEventTypeFlags.DOWNSTREAM | GstEventTypeFlags.SERIALIZED | GstEventTypeFlags.STICKY,
		TOC          = ( 120 << 8 ) | GstEventTypeFlags.DOWNSTREAM | GstEventTypeFlags.SERIALIZED | GstEventTypeFlags.STICKY | GstEventTypeFlags.STICKY_MULTI,

		/* non-sticky downstream serialized */
		SEGMENT_DONE = ( 150 << 8 ) | GstEventTypeFlags.DOWNSTREAM | GstEventTypeFlags.SERIALIZED,
		GAP          = ( 160 << 8 ) | GstEventTypeFlags.DOWNSTREAM | GstEventTypeFlags.SERIALIZED,

		/+* upstream events +/
		QOS         = ( 190 << 8 ) | GstEventTypeFlags.UPSTREAM,
		SEEK        = ( 200 << 8 ) | GstEventTypeFlags.UPSTREAM,
		NAVIGATION  = ( 210 << 8 ) | GstEventTypeFlags.UPSTREAM,
		LATENCY     = ( 220 << 8 ) | GstEventTypeFlags.UPSTREAM,
		STEP        = ( 230 << 8 ) | GstEventTypeFlags.UPSTREAM,
		RECONFIGURE = ( 240 << 8 ) | GstEventTypeFlags.UPSTREAM,
		TOC_SELECT  = ( 250 << 8 ) | GstEventTypeFlags.UPSTREAM,

		/+* custom events start here +/
		CUSTOM_UPSTREAM          = ( 270 << 8 ) | GstEventTypeFlags.UPSTREAM,
		CUSTOM_DOWNSTREAM        = ( 280 << 8 ) | GstEventTypeFlags.DOWNSTREAM | GstEventTypeFlags.SERIALIZED,
		CUSTOM_DOWNSTREAM_OOB    = ( 290 << 8 ) | GstEventTypeFlags.DOWNSTREAM,
		CUSTOM_DOWNSTREAM_STICKY = ( 300 << 8 ) | GstEventTypeFlags.DOWNSTREAM | GstEventTypeFlags.SERIALIZED | GstEventTypeFlags.STICKY | GstEventTypeFlags.STICKY_MULTI,
		CUSTOM_BOTH              = ( 310 << 8 ) | GstEventTypeFlags.UPSTREAM | GstEventTypeFlags.DOWNSTREAM | GstEventTypeFlags.SERIALIZED,
		CUSTOM_BOTH_OOB          = ( 320 << 8 ) | GstEventTypeFlags.UPSTREAM | GstEventTypeFlags.DOWNSTREAM
	}
	alias GstEventType EventType;

addEnums: end

addStructs: start
	struct GstBinPrivate{}

	public struct GstBuffer
	{
		GstMiniObject  mini_object;

		/*< public >*/ /* with COW */
		GstBufferPool* pool;

		/* timestamp */
		GstClockTime   pts;
		GstClockTime   dts;
		GstClockTime   duration;

		/* media specific offset */
		guint64        offset;
		guint64        offset_end;
	}

	public struct GstObjectClass
	{
		GInitiallyUnownedClass parent_class;

		const gchar* path_string_separator;

		/* signals */
		extern(C) void function(GstObject* object, GstObject* orig, GParamSpec* pspec) deep_notify;

		/*< public >*/
		/* virtual methods for subclasses */

		/*< private >*/
		gpointer _gst_reserved[GST_PADDING];
	}

	struct GstMessage
	{
		GstMiniObject   mini_object;

		/*< public > *//* with COW */
		GstMessageType  type;
		guint64         timestamp;
		GstObject*      src;
		guint32         seqnum;

		/*< private >*//* with MESSAGE_LOCK */
		GMutex          lock;                 /* lock and cond for async delivery */
		GCond           cond;
	}

	public struct GstMiniObject
	{
		GType   type;

		/*< public >*/ /* with COW */
		gint    refcount;
		gint    lockstate;
		guint   flags;

		extern(C) GstMiniObject* function(GstMiniObject* obj) copy;
		extern(C) gboolean       function(GstMiniObject* obj) dispose;
		extern(C) void           function(GstMiniObject* obj) free;

		/* < private > */
		/* Used to keep track of weak ref notifies and qdata */
		guint n_qdata;
		gpointer qdata;
	}
addStructs: end

addTypes: start
addTypes: end

addFuncts: start
addFuncts: end

addUnions: start
addUnions: end

addConstants: start
	/***** default padding of structures *****/
	const long GST_PADDING = 4;

	/***** padding for very extensible base classes *****/
	const long GST_PADDING_LARGE = 20;

	//These times might be clean to define as GstClockTimes instead of long (maybe):

	//#define G_USEC_PER_SEC 1000000 //This should be in glib...
	const ulong G_USEC_PER_SEC = 1000000uL;
	//#define GST_SECOND  (G_USEC_PER_SEC * G_GINT64_CONSTANT (1000))
	const ulong GST_SECOND = (G_USEC_PER_SEC * 1000uL);

	public alias GST_SECOND SECOND;

	//This one is an undefined GstClockTime. How can this be ulong???
	//I guess it should be long...???
	//#define GST_CLOCK_TIME_NONE		((GstClockTime) -1)
	const long GST_CLOCK_TIME_NONE = -1L;
	public alias GST_CLOCK_TIME_NONE CLOCK_TIME_NONE;
addConstants: end

# must start with wrap

wrap: gstreamer
srcout: srcgstreamer

###########################################################
### GStreamer #############################################
###########################################################

file: gstreamer-Gst.html
class: GStreamer
prefix: gst_
import: glib.ErrorG
import: glib.GException
import: glib.Str
import: glib.OptionGroup
structWrap: GOptionGroup* OptionGroup

inout: gst_version major
inout: gst_version minor
inout: gst_version micro
inout: gst_version nano
inout: gst_init argv
array: gst_init argv argc
inout: gst_init_check argv
array: gst_init_check argv argc
outFile: gstreamer

file: GstAllocator.html
struct: GstAllocator
class: Allocator
prefix: gst_allocator_
import: glib.Str
import: gstreamer.Memory
structWrap: GstAllocator* Allocator
structWrap: GstMemory* Memory
outFile: Allocator

file: gstreamer-GstAtomicQueue.html
struct: GstAtomicQueue
class: AtomicQueue
prefix: gst_atomic_queue_
outFile: AtomicQueue

file: GstBin.html
struct: GstBin
ctorStruct: GstElement
class: Bin
prefix: gst_bin_
import: glib.Str
import: gstreamer.Element
import: gstreamer.Iterator
import: gstreamer.Pad
structWrap: GstElement* Element
structWrap: GstIterator* Iterator
structWrap: GstPad* Pad

code: start
	/** */
	public this(Element elem)
	{
		super( elem.getElementStruct() );
		this.gstBin = cast(GstBin*)elem.getElementStruct();
	}
code: end
outFile: Bin

file: gstreamer-GstBuffer.html
struct: GstBuffer
nostruct: GstBuffer
class: Buffer
prefix: gst_buffer_
import: glib.Str
import: gstreamer.Allocator
import: gstreamer.Memory
import: gstreamer.Meta
structWrap: GstAllocator* Allocator
structWrap: GstBuffer* Buffer
structWrap: GstMemory* Memory
structWrap: GstMeta* Meta

array: gst_buffer_new_wrapped data size
out: gst_buffer_get_sizes offset
out: gst_buffer_get_sizes maxsize
out: gst_buffer_get_sizes_range offset
out: gst_buffer_get_sizes_range maxsize
out: gst_buffer_find_memory idx
out: gst_buffer_find_memory length
out: gst_buffer_find_memory skip
out: gst_buffer_map info
out: gst_buffer_map_range info
inout: gst_buffer_unmap info
array: gst_buffer_memcmp mem size
array: gst_buffer_extract dest size
array: gst_buffer_fill src size
inout: gst_buffer_replace obuf
outFile: Buffer

file: gstreamer-GstBufferList.html
struct: GstBufferList
class: BufferList
prefix: gst_buffer_list_
import: gstreamer.BufferList
structWrap: GstBuffer* Buffer
structWrap: GstBufferList* BufferList
outFile: BufferList

file: gstreamer-GstBufferPool.html
struct: GstBufferPool
class: BufferPool
prefix: gst_buffer_pool_
import: glib.Str
import: gstreamer.Allocator
import: gstreamer.Buffer
import: gstreamer.Caps
import: gstreamer.Structure
structWrap: GstAllocator* Allocator
structWrap: GstBuffer* Buffer
structWrap: GstCaps* Caps
structWrap: GstStructure* Structure

out: gst_buffer_pool_config_get_params caps
out: gst_buffer_pool_config_get_params size
out: gst_buffer_pool_config_get_params min_buffers
out: gst_buffer_pool_config_get_params max_buffers
inout: gst_buffer_pool_config_get_allocator allocator
out: gst_buffer_pool_acquire_buffer buffer
outFile: BufferPool

file: GstBus.html
struct: GstBus
class: Bus
prefix: gst_bus_
import: glib.Str
import: glib.Source
import: gstreamer.Message
structWrap: GSource* Source
structWrap: GstBus* Bus
structWrap: GstMessage* Message

nocode: gst_bus_add_watch
nocode: gst_bus_set_sync_handler
code: start
	/**
	 * Adds a bus watch to the default main context with the default priority.
	 * This function is used to receive asynchronous messages in the main loop.
	 * The watch can be removed using g_source_remove() or by returning FALSE
	 * from func.
	 * MT safe.
	 * Params:
	 *  dlg = A function to call when a message is received.
	 * Returns:
	 *  The event source id.
	 */
	public uint addWatch( bool delegate(Message) dlg )
	{
		onWatchListener = dlg;
		return gst_bus_add_watch(gstBus, cast(GstBusFunc)&watchCallBack, cast(void*)this);
	}

	bool delegate(Message) onWatchListener;

	extern(C) static gboolean watchCallBack(GstBus* bus, GstMessage* msg, Bus bus_d )//gpointer data)
	{
		Message msg_d = new Message( msg );

		return bus_d.onWatchListener( msg_d );
	}
	
	 /**
	  * Use this for making an XOverlay.
	  * Sets the synchronous handler on the bus. The function will be called
	  * every time a new message is posted on the bus. Note that the function
	  * will be called in the same thread context as the posting object. This
	  * function is usually only called by the creator of the bus. Applications
	  * should handle messages asynchronously using the gst_bus watch and poll
	  * functions.
	  * You cannot replace an existing sync_handler. You can pass NULL to this
	  * function, which will clear the existing handler.
	  * Params:
	  *  dlg = The handler function to install
	  */
	public void setSyncHandler( GstBusSyncReply delegate(Message) dlg )
	{
		onSyncHandlerListener = dlg;
		gst_bus_set_sync_handler(gstBus, cast(GstBusSyncHandler)&syncHandlerCallBack, cast(void*)this);
	}
	
	GstBusSyncReply delegate(Message) onSyncHandlerListener;
	
	extern(C) static GstBusSyncReply syncHandlerCallBack(GstBus * bus, GstMessage * msg, Bus bus_d )//GstPipeline * pipeline)
	//extern(C) static gboolean watchCallBack(GstBus* bus, GstMessage* msg, Bus bus_d )//gpointer data)
	{
		Message msg_d = new Message( msg );
		
		return bus_d.onSyncHandlerListener( msg_d );
	}
code: end
outFile: Bus

file: gstreamer-GstCaps.html
struct: GstCaps
class: Caps
prefix: gst_caps_
prefix: gst_
override: toString
import: glib.Str
import: gobject.Value
import: gstreamer.Structure
structWrap: GValue* Value
structWrap: GstCaps* Caps
structWrap: GstStructure* Structure

inout: gst_caps_replace caps

nocode: gst_caps_new_any

code: start
	/**
	 * Creates a new GstCaps that indicates that it is compatible with
	 * any media format.
	 * Returns:
	 *  the new GstCaps
	 */
	public static Caps newAny()
	{
		// GstCaps* gst_caps_new_any (void);
		auto p = cast(GstCaps*)gst_caps_new_any();

		if(p is null)
		{
			throw new ConstructionException("null returned by gst_caps_new_any");
		}

		return new Caps(cast(GstCaps*)p );
	}
code: end
outFile: Caps

file: gstreamer-GstSample.html
struct: GstSample
class: Sample
prefix: gst_sample_
import: gstreamer.Buffer
import: gstreamer.Caps
import: gstreamer.Segment
import: gstreamer.Structure
structWrap: GstBuffer* Buffer
structWrap: GstCaps* Caps
structWrap: GstSample* Sample
structWrap: GstSegment* Segment
structWrap: GstStructure* Structure
outFile: Sample

file: GstChildProxy.html
struct: GstChildProxy
class: ChildProxyT
template: TStruct
prefix: gst_child_proxy_
import: glib.Str
import: gobject.ObjectG
import: gobject.ParamSpec
import: gobject.Value
structWrap: GObject* ObjectG
structWrap: GParamSpec* ParamSpec
structWrap: GValue* Value

out: gst_child_proxy_lookup target
out: gst_child_proxy_lookup pspec
interface: ChildProxyIF
outFile: ChildProxyT

file: GstClock.html
struct: GstClock
class: Clock
prefix: gst_clock_
import: glib.Str
structWrap: GstClock* Clock

out: gst_clock_add_observation r_squared
out: gst_clock_get_calibration internal
out: gst_clock_get_calibration external
out: gst_clock_get_calibration rate_num
out: gst_clock_get_calibration rate_denom
inout: gst_clock_id_wait jitter
outFile: Clock

#file: gstreamer-gstconfig.html

file: GstControlBinding.html
struct: GstControlBinding
class: ControlBinding
prefix: gst_control_binding_
import: gobject.Value
import: gstreamer.ObjectGst
structWrap: GValue* Value
structWrap: GstObject* ObjectGst

array: gst_control_binding_get_value_array values n_values
array: gst_control_binding_get_g_value_array values n_values
outFile: ControlBinding

file: GstControlSource.html
struct: GstControlSource
class: ControlSource
prefix: gst_control_source_
out: gst_control_source_get_value value
array: gst_control_source_get_value_array values n_values
outFile: ControlSource

file: gstreamer-GstDateTime.html
struct: GstDateTime
class: DateTime
prefix: gst_date_time_
import: glib.Str
#import: glib.DateTime
import: gstreamer.DateTime
#structWrap: GDateTime* DateTime
structWrap: GstDateTime* DateTime
outFile: DateTime

file: GstElement.html
struct: GstElement
class: Element
prefix: gst_element_
import: glib.Str
import: gtkc.gobject
import: glib.ListG
import: gstreamer.Bus
import: gstreamer.Caps
import: gstreamer.Clock
import: gstreamer.ElementFactory
import: gstreamer.Event
import: gstreamer.Iterator
import: gstreamer.Message
import: gstreamer.Pad
import: gstreamer.PadTemplate
import: gstreamer.Query
structWrap: GList ListG
structWrap: GstBus* Bus
structWrap: GstCaps* Caps
structWrap: GstClock* Clock
structWrap: GstElement* Element
structWrap: GstElementFactory* ElementFactory
structWrap: GstEvent* Event
structWrap: GstIterator* Iterator
structWrap: GstMessage* Message
structWrap: GstPad* Pad
structWrap: GstPadTemplate* PadTemplate
structWrap: GstQuery* Query

out: gst_element_get_state state
out: gst_element_get_state pending
inout: gst_element_query_convert src_format
out: gst_element_query_convert dest_val
inout: gst_element_query_position cur
inout: gst_element_query_duration duration

code: start
	/**
	 * Queries an element for the stream position.
	 * This is a convenience function for gstreamerD.
	 * Returns:
	 *  The current position in nanoseconds - GstFormat.TIME.
	 */
	public long queryPosition()
	{
		GstFormat form = GstFormat.TIME;
		long cur_pos;
		queryPosition( form, cur_pos );
		return cur_pos;
	}

	/**
	 * Queries an element for the stream duration.
	 * This is a convenience function for gstreamerD.
	 * Returns:
	 *  The duration in nanoseconds - GstFormat.TIME.
	 */
	public long queryDuration()
	{
		GstFormat form = GstFormat.TIME;
		long cur_dur;
		queryDuration( form, cur_dur );
		return cur_dur;
	}

	/**
	 *	This set's the filename for a filesrc element.
	 */
	public void location( string set )
	{
		//g_object_set( G_OBJECT(getElementStruct()), "location", set, NULL);
		setProperty("location", set);
	}

	/**
	 * Set the caps property of an Element.
	 */
	void caps( Caps cp )
	{
		g_object_set( getElementStruct(), Str.toStringz("caps"), cp.getCapsStruct(), null );
	}

	/**
	* For your convenience in gstreamerD: you can seek to the
	* position of the pipeline measured in time_nanoseconds.
	*/
	public int seek( long time_nanoseconds ) //gint64
	{
		return seek( 1.0, GstFormat.TIME, GstSeekFlags.FLUSH,
								GstSeekType.SET, time_nanoseconds,
								GstSeekType.NONE, GST_CLOCK_TIME_NONE);
	}
	
	/**
	* Get's all the pads from an element in a Pad[]. FIXME: This a hackish mess.
	*/
	public Pad[] pads()
	{
		Pad[] result = new Pad[0];
		
		Iterator iter = iteratePads();
		GstPad* obu_c = null;
		iter.next( cast(void**) &obu_c );
		while( obu_c !is null )
		{
			Pad tmpobu = new Pad( obu_c );
			//writefln( "iterating Padname: ", tmpobu.getName() );
			result.length = result.length + 1;
			result[result.length-1] = tmpobu;	
			
			obu_c = null;
			iter.next( cast(void**) &obu_c );
		}
		//writefln("no more pads.");
		return result;
	}
code: end
outFile: Element

file: GstElementFactory.html
struct: GstElementFactory
class: ElementFactory
prefix: gst_element_factory_
prefix: gst_element_
import: glib.Str
import: glib.ListG
import: gstreamer.Caps
import: gstreamer.Element
import: gstreamer.Plugin
structWrap: GList* ListG
structWrap: GstCaps* Caps
structWrap: GstElement* Element
structWrap: GstElementFactory* ElementFactory
structWrap: GstPlugin* Plugin

code: start
	/**
	 * Create a new element of the type defined by the given element factory.
	 * The element will receive a guaranteed unique name,
	 * consisting of the element factory name and a number.
	 * Params:
	 *  factoryname = a named factory to instantiate
	 * Returns:
	 *  new GstElement or NULL if unable to create element
	 */
	public static Element make( string factoryname )
	{
		// GstElement* gst_element_factory_make (const gchar *factoryname,  const gchar *name);
		auto p = gst_element_factory_make(Str.toStringz(factoryname), null );

		if(p is null)
		{
			throw new ConstructionException("null returned by gst_element_factory_make");
		}

		return new Element( p );
	}
code: end
outFile: ElementFactory

file: gstreamer-GstGError.html
prefix: gst_
import: glib.Str
outFile: GError

file: gstreamer-GstMiniObject.html
struct: GstMiniObject
nostruct: GstMiniObject
class: MiniObject
prefix: gst_mini_object_
import: glib.Str
import: gobject.ParamSpec
import: gobject.Value
structWrap: GstMiniObject* MiniObject
structWrap: GParamSpec* ParamSpec
structWrap: GValue* Value
inout: gst_mini_object_replace olddata
outFile: MiniObject

file: GstObject.html
struct: GstObject
class: ObjectGst
prefix: gst_object_
prefix: gst_
#libxml2 missing:
nocode: gst_object_save_thyself
nocode: gst_object_restore_thyself
nocode: gst_class_signal_emit_by_name
#this is removed because of GstObjectClass* not working yet
nocode: gst_class_signal_connect
import: glib.Str
import: gobject.ObjectG
import: glib.ErrorG
import: glib.ListG
import: gobject.ParamSpec
structWrap: GstObject* ObjectGst
structWrap: GObject* ObjectG
structWrap: GError* ErrorG
structWrap: GList* ListG
structWrap: GParamSpec* ParamSpec
array: gst_object_default_deep_notify excluded_props
inout: gst_object_replace oldobj
outFile: ObjectGst

file: gstreamer-GstEvent.html
struct: GstEvent
class: Event
prefix: gst_event_
prefix: gst_
import: glib.Str
import: gstreamer.Structure
import: gstreamer.TagList
import: gstreamer.MiniObject
structWrap: GstEvent* Event
structWrap: GstStructure* Structure
structWrap: GstTagList* TagList
structWrap: GstMiniObject* MiniObject
structWrap: GstMiniObject MiniObject

out: gst_event_parse_buffer_size format
out: gst_event_parse_buffer_size minsize
out: gst_event_parse_buffer_size maxsize
out: gst_event_parse_buffer_size async
inout: gst_event_parse_latency latency
inout: gst_event_parse_new_segment update
inout: gst_event_parse_new_segment rate
inout: gst_event_parse_new_segment format
out: gst_event_parse_new_segment start
out: gst_event_parse_new_segment stop
out: gst_event_parse_new_segment position
inout: gst_event_parse_new_segment_full update
inout: gst_event_parse_new_segment_full rate
inout: gst_event_parse_new_segment_full applied_rate
inout: gst_event_parse_new_segment_full format
out: gst_event_parse_new_segment_full start
out: gst_event_parse_new_segment_full stop
out: gst_event_parse_new_segment_full position
out: gst_event_parse_qos proportion
out: gst_event_parse_qos diff
out: gst_event_parse_qos timestamp
out: gst_event_parse_seek rate
out: gst_event_parse_seek format
out: gst_event_parse_seek flags
out: gst_event_parse_seek start_type
out: gst_event_parse_seek start
out: gst_event_parse_seek stop_type
out: gst_event_parse_seek stop
out: gst_event_parse_tag taglist

nocode: gst_event_new_buffer_size
code: start
	/**
	 * Create a new buffersize event. The event is sent downstream and notifies
	 * elements that they should provide a buffer of the specified dimensions.
	 * When the async flag is set, a thread boundary is prefered.
	 * Params:
	 *  format = buffer format
	 *  minsize = minimum buffer size
	 *  maxsize = maximum buffer size
	 *  async = thread behavior
	 * Returns:
	 *  a new GstEvent
	 */
	public static Event newBufferSize(GstFormat format, long minsize, long maxsize, int async)
	{
		// GstEvent* gst_event_new_buffer_size (GstFormat format,  gint64 minsize,  gint64 maxsize,  gboolean async);
		auto p = gst_event_new_buffer_size(format, minsize, maxsize, async);

		if(p is null)
		{
			throw new ConstructionException("null returned by gst_event_new_buffer_size");
		}

		return new Event(cast(GstEvent*)p);
	}
code: end
nocode: gst_event_new_eos
code: start
	/**
	 * Create a new EOS event. The eos event can only travel downstream
	 * synchronized with the buffer flow. Elements that receive the EOS
	 * event on a pad can return UNEXPECTED as a GstFlowReturn when data
	 * after the EOS event arrives.
	 * The EOS event will travel down to the sink elements in the pipeline
	 * which will then post the GST_MESSAGE_EOS on the bus after they have
	 * finished playing any buffered data.
	 * When all sinks have posted an EOS message, the EOS message is
	 * forwarded to the application.
	 * Returns:
	 *  The new EOS event.
	 */
	public static Event newEOS()
	{
		// GstEvent* gst_event_new_eos (void);
		auto p = gst_event_new_eos();

		if(p is null)
		{
			throw new ConstructionException("null returned by gst_event_new_eos");
		}

		return new Event(cast(GstEvent*)p );
	}
code: end
nocode: gst_event_new_flush_start
code: start
	/**
	 * Allocate a new flush start event. The flush start event can be send
	 * upstream and downstream and travels out-of-bounds with the dataflow.
	 * It marks pads as being in a WRONG_STATE to process more data.
	 * Elements unlock and blocking functions and exit their streaming functions
	 * as fast as possible.
	 * This event is typically generated after a seek to minimize the latency
	 * after the seek.
	 * Returns:
	 *  A new flush start event.
	 */
	public static Event newFlushStart()
	{
		// GstEvent* gst_event_new_flush_start (void);
		auto p = gst_event_new_flush_start();

		if(p is null)
		{
			throw new ConstructionException("null returned by gst_event_new_flush_start");
		}

		return new Event(cast(GstEvent*)p );
	}
code: end
nocode: gst_event_new_flush_stop
code: start
	/**
	 * Allocate a new flush stop event. The flush start event can be send
	 * upstream and downstream and travels out-of-bounds with the dataflow.
	 * It is typically send after sending a FLUSH_START event to make the
	 * pads accept data again.
	 * Elements can process this event synchronized with the dataflow since
	 * the preceeding FLUSH_START event stopped the dataflow.
	 * This event is typically generated to complete a seek and to resume
	 * dataflow.
	 * Returns:
	 *  A new flush stop event.
	 */
	public static Event newFlushStop()
	{
		// GstEvent* gst_event_new_flush_stop (void);
		auto p = gst_event_new_flush_stop();

		if(p is null)
		{
			throw new ConstructionException("null returned by gst_event_new_flush_stop");
		}

		return new Event(cast(GstEvent*)p );
	}
code: end
nocode: gst_event_new_navigation
code: start
/**
	 * Create a new navigation event from the given description.
	 * Params:
	 *  structure = description of the event
	 * Returns:
	 *  a new GstEvent
	 */
	public static Event newNavigation(Structure structure)
	{
		// GstEvent* gst_event_new_navigation (GstStructure *structure);
		auto p = gst_event_new_navigation((structure is null) ? null : structure.getStructureStruct());

		if(p is null)
		{
			throw new ConstructionException("null returned by gst_event_new_navigation");
		}

		return new Event(cast(GstEvent*)p);
	}
code: end
outFile: Event

file: gstreamer-GstFormat.html
prefix: gst_format_
prefix: gst_
import: glib.Str
import: gstreamer.Iterator
structWrap: GstIterator* Iterator
array: gst_formats_contains formats
outFile: Format

file: GstGhostPad.html
struct: GstGhostPad
ctorStruct: GstPad
class: GhostPad
extend: GstPad
prefix: gst_ghost_pad_
prefix: gst_
import: glib.Str
import: gstreamer.Pad
import: gstreamer.PadTemplate
structWrap: GstGhostPad* GhostPad
structWrap: GstPad* Pad
structWrap: GstPadTemplate* PadTemplate
outFile: GhostPad

file: gstreamer-GstIterator.html
struct: GstIterator
class: Iterator
prefix: gst_iterator_
prefix: gst_
import: glib.Str
import: gthread.Mutex
structWrap: GMutex* Mutex
structWrap: GstIterator* Iterator

inout: gst_iterator_new master_cookie
outFile: Iterator

file: GstPad.html
struct: GstPad
class: Pad
prefix: gst_pad_
prefix: gst_
#libxml2 missing:
nocode: gst_pad_load_and_link
import: glib.Str
import: gstreamer.Element
import: gstreamer.MiniObject
import: gstreamer.PadTemplate
import: gstreamer.Caps
import: gstreamer.Buffer
import: gstreamer.Event
import: gstreamer.Query
import: glib.ListG
structWrap: GstPad* Pad
structWrap: GstElement* Element
structWrap: GstMiniObject* MiniObject
structWrap: GstPadTemplate* PadTemplate
structWrap: GstCaps* Caps
structWrap: GstBuffer* Buffer
structWrap: GstEvent* Event
structWrap: GstQuery* Query
structWrap: GList* ListG

out: gst_pad_alloc_buffer buf
out: gst_pad_alloc_buffer_and_set_caps buf
inout: gst_pad_get_range buffer
inout: gst_pad_pull_range buffer
inout: gst_pad_query_position format
out: gst_pad_query_position cur
inout: gst_pad_query_duration format
out: gst_pad_query_duration duration
inout: gst_pad_query_convert dest_format
out: gst_pad_query_convert dest_val
inout: gst_pad_query_peer_position format
out: gst_pad_query_peer_position cur
inout: gst_pad_query_peer_duration format
out: gst_pad_query_peer_duration duration
inout: gst_pad_query_peer_convert dest_format
out: gst_pad_query_peer_convert dest_val
#TODO: zero terminated array?
#array: gst_pad_get_query_types Return
#array: gst_pad_get_query_types_default Return
code: start
	/**
	 * Sets our main struct and passes it to the parent class.
	 * This one is additional to make gstreamer.Element addOnPadAdded()
	 * working without changes.
	 */
	public this (GObject* gstPad)
	{
		super(cast(GstObject*)gstPad);
		this.gstPad = cast(GstPad*) gstPad;
	}
	
	/**
	 * Queries a pad for the stream position.
	 * This is a convenience function for gstreamerD.
	 * Returns:
	 *  The current position in nanoseconds - GstFormat.TIME.
	 */
	public long queryPosition()
	{
		GstFormat form = GstFormat.TIME;
		long cur_pos;
		queryPosition( form, cur_pos );
		return cur_pos;
	}

	/**
	 * Queries a pad for the stream duration.
	 * This is a convenience function for gstreamerD.
	 * Returns:
	 *  The duration in nanoseconds - GstFormat.TIME.
	 */
	public long queryDuration()
	{
		GstFormat form = GstFormat.TIME;
		long cur_dur;
		queryDuration( form, cur_dur );
		return cur_dur;
	}
	
code: end
outFile: Pad
#########
#########for pad signals disconnecting add this with hand editing:
#########also this would be needed on all
#########gtkD signals.
#	protected uint padAddedHandlerId;
#	void delegate(Pad, Element)[] onPadAddedListeners;
#	void addOnPadAdded(void delegate(Pad, Element) dlg)
#	{
#		if ( !("pad-added" in connectedSignals) )
#		{
#			padAddedHandlerId = Signals.connectData(
#			getStruct(),
#			"pad-added",
#			cast(GCallback)&callBackPadAdded,
#			cast(void*)this,
#			null,
#			cast(ConnectFlags)0);
#			connectedSignals["pad-added"] = 1;
#		}
#		onPadAddedListeners ~= dlg;
#	}
#	extern(C) static void callBackPadAdded(GstElement* gstelementStruct, GObject* newPad, Element element)
#	{
#		bit consumed = false;
#		
#		foreach ( void delegate(Pad, Element) dlg ; element.onPadAddedListeners )
#		{
#			dlg(new Pad(newPad), element);
#		}
#		
#		return consumed;
#	}
#	void disconnectOnPadAdded()
#	{
#		if( "pad-added" in connectedSignals )
#		{
#			Signals.handlerDisconnect( getStruct(), padAddedHandlerId );
#			padAddedHandlerId = 0;
#			connectedSignals["pad-added"] = 0;
#			onPadAddedListeners = null;
#		}
#	}

file: gstreamer-GstMessage.html
struct: GstMessage
nostruct: GstMessage
class: Message
prefix: gst_message_
prefix: gst_
import: glib.Str
import: glib.Quark
import: gstreamer.Structure
import: gstreamer.ObjectGst
import: gstreamer.Clock
import: glib.ErrorG
import: gstreamer.TagList
structWrap: GstMessage* Message
structWrap: GQuark Quark
structWrap: GstStructure* Structure
structWrap: GstObject* ObjectGst
structWrap: GstClock* Clock
structWrap: GError* ErrorG
structWrap: GstTagList* TagList

out: gst_message_parse_clock_lost clock
out: gst_message_parse_clock_provide clock
out: gst_message_parse_clock_provide ready
out: gst_message_parse_error debug
out: gst_message_parse_error gerror
out: gst_message_parse_info debug
out: gst_message_parse_info gerror
out: gst_message_parse_warning debug
out: gst_message_parse_warning gerror
out: gst_message_parse_new_clock clock
out: gst_message_parse_segment_done format
out: gst_message_parse_segment_done position
out: gst_message_parse_segment_start format
out: gst_message_parse_segment_start position
out: gst_message_parse_buffering percent
out: gst_message_parse_duration format
out: gst_message_parse_duration duration
out: gst_message_parse_async_start new_base_time

nocode: gst_message_parse_tag
#I'm not so sure about the following:
nocode: gst_message_type_to_quark
nocode: gst_message_new_element
nocode: gst_message_new_new_clock
nocode: gst_message_new_segment_done
nocode: gst_message_new_segment_start
nocode: gst_message_new_warning
nocode: gst_message_new_state_dirty
nocode: gst_message_new_eos
nocode: gst_message_new_error
nocode: gst_message_new_info
nocode: gst_message_new_latency
nocode: gst_message_new_async_start

#This is a way to get the type of the message:
code: start
	/**
	* Get the type of the message.
	*/
	public GstMessageType type()
	{
		return cast(GstMessageType)getMessageStruct().type;
	}
	
	/**
	 * Get the src (the element that originated the message) of the message.
	 */
	public ObjectGst src()
	{
		return new ObjectGst( cast(GstObject*)getMessageStruct().src );
	}

	/**
	 * Get the structure.
	 */
	public Structure structure()
	{
		return new Structure( getMessageStruct().structure );
	}

	/**
	 * Extracts the tag list from the GstMessage. The tag list returned in the
	 * output argument is a copy; the caller must free it when done.
	 * MT safe.
	 * Params:
	 *  tagList = Return location for the tag-list.
	 */
	public TagList parseTag()
	{
		// void gst_message_parse_tag (GstMessage *message,  GstTagList **tag_list);
		GstTagList* tag_list_c;
		gst_message_parse_tag(gstMessage, &tag_list_c);

		if ( tag_list_c is null )
		{
			return null;
		}

		return new TagList(tag_list_c);
	}

	//I'm not so sure about the following:
	/**
	 * Get the unique quark for the given message type.
	 * Params:
	 *  type = the message type
	 * Returns:
	 *  the quark associated with the message type
	 */
	public static Quark typeToQuark(GstMessageType type)
	{
		// GQuark gst_message_type_to_quark (GstMessageType type);
		return new Quark( cast(uint*)gst_message_type_to_quark(type) );
	}

	/**
	 * Create a new element-specific message. This is meant as a generic way of
	 * allowing one-way communication from an element to an application, for example
	 * "the firewire cable was unplugged". The format of the message should be
	 * documented in the element's documentation. The structure field can be NULL.
	 * MT safe.
	 * Params:
	 *  src = The object originating the message.
	 *  structure = The structure for the message. The message will take ownership of
	 *  the structure.
	 * Returns:
	 *  The new element message.
	 */
	public static Message newElement(ObjectGst src, Structure structure)
	{
		// GstMessage* gst_message_new_element (GstObject *src,  GstStructure *structure);
		auto p = gst_message_new_element((src is null) ? null : src.getObjectGstStruct(), (structure is null) ? null : structure.getStructureStruct());

		if(p is null)
		{
			throw new ConstructionException("null returned by gst_message_new_element");
		}

		return new Message(cast(GstMessage*)p);
	}

	/**
	 * Create a new clock message. This message is posted whenever the
	 * pipeline selectes a new clock for the pipeline.
	 * MT safe.
	 * Params:
	 *  src = The object originating the message.
	 *  clock = the new selected clock
	 * Returns:
	 *  The new new clock message.
	 */
	public static Message newNewClock(ObjectGst src, Clock clock)
	{
		// GstMessage* gst_message_new_new_clock (GstObject *src,  GstClock *clock);
		auto p = gst_message_new_new_clock((src is null) ? null : src.getObjectGstStruct(), (clock is null) ? null : clock.getClockStruct());

		if(p is null)
		{
			throw new ConstructionException("null returned by gst_message_new_new_clock");
		}

		return new Message(cast(GstMessage*)p );
	}

	/**
	 * Create a new segment done message. This message is posted by elements that
	 * finish playback of a segment as a result of a segment seek. This message
	 * is received by the application after all elements that posted a segment_start
	 * have posted the segment_done.
	 * MT safe.
	 * Params:
	 *  src = The object originating the message.
	 *  format = The format of the position being done
	 *  position = The position of the segment being done
	 * Returns:
	 *  The new segment done message.
	 */
	public static Message newSegmentDone(ObjectGst src, GstFormat format, long position)
	{
		// GstMessage* gst_message_new_segment_done (GstObject *src,  GstFormat format,  gint64 position);
		auto p = gst_message_new_segment_done((src is null) ? null : src.getObjectGstStruct(), format, position);

		if(p is null)
		{
			throw new ConstructionException("null returned by gst_message_new_segment_done");
		}

		return new Message(cast(GstMessage*)p );
	}

	/**
	 * Create a new segment message. This message is posted by elements that
	 * start playback of a segment as a result of a segment seek. This message
	 * is not received by the application but is used for maintenance reasons in
	 * container elements.
	 * MT safe.
	 * Params:
	 *  src = The object originating the message.
	 *  format = The format of the position being played
	 *  position = The position of the segment being played
	 * Returns:
	 *  The new segment start message.
	 */
	public static Message newSegmentStart(ObjectGst src, GstFormat format, long position)
	{
		// GstMessage* gst_message_new_segment_start (GstObject *src,  GstFormat format,  gint64 position);
		auto p = gst_message_new_segment_start((src is null) ? null : src.getObjectGstStruct(), format, position);

		if(p is null)
		{
			throw new ConstructionException("null returned by gst_message_new_segment_start");
		}

		return new Message(cast(GstMessage*)p );
	}

	/**
	 * Create a new warning message. The message will make copies of error and
	 * debug.
	 * MT safe.
	 * Params:
	 *  src = The object originating the message.
	 *  error = The GError for this message.
	 *  debug = A debugging string for something or other.
	 * Returns:
	 *  The new warning message.
	 */
	public static Message newWarning(ObjectGst src, ErrorG error, string dbug)
	{
		// GstMessage* gst_message_new_warning (GstObject *src,  GError *error,  gchar *debug);
		auto p = gst_message_new_warning((src is null) ? null : src.getObjectGstStruct(), (error is null) ? null : error.getErrorGStruct(), Str.toStringz(dbug));

		if(p is null)
		{
			throw new ConstructionException("null returned by gst_message_new_warning");
		}

		return new Message(cast(GstMessage*)p );
	}

	/**
	 * Create a state dirty message. This message is posted whenever an element
	 * changed its state asynchronously and is used internally to update the
	 * states of container objects.
	 * MT safe.
	 * Params:
	 *  src = the object originating the message
	 * Returns:
	 *  The new state dirty message.
	 */
	public static Message newStateDirty(ObjectGst src)
	{
		// GstMessage* gst_message_new_state_dirty (GstObject *src);
		auto p = gst_message_new_state_dirty((src is null) ? null : src.getObjectGstStruct());

		if(p is null)
		{
			throw new ConstructionException("null returned by gst_message_new_state_dirty");
		}

		return new Message(cast(GstMessage*)p );
	}

	/**
	 * Create a new eos message. This message is generated and posted in
	 * the sink elements of a GstBin. The bin will only forward the EOS
	 * message to the application if all sinks have posted an EOS message.
	 * MT safe.
	 * Params:
	 *  src = The object originating the message.
	 * Returns:
	 *  The new eos message.
	 */
	public static Message newEOS(ObjectGst src)
	{
		// GstMessage* gst_message_new_eos (GstObject *src);
		auto p = gst_message_new_eos((src is null) ? null : src.getObjectGstStruct());

		if(p is null)
		{
			throw new ConstructionException("null returned by gst_message_new_eos");
		}

		return new Message(cast(GstMessage*)p );
	}

	/**
	 * Create a new error message. The message will copy error and
	 * debug. This message is posted by element when a fatal event
	 * occured. The pipeline will probably (partially) stop. The application
	 * receiving this message should stop the pipeline.
	 * MT safe.
	 * Params:
	 *  src = The object originating the message.
	 *  error = The GError for this message.
	 *  debug = A debugging string for something or other.
	 * Returns:
	 *  The new error message.
	 */
	public static Message newError(ObjectGst src, ErrorG error, string dbug)
	{
		// GstMessage* gst_message_new_error (GstObject *src,  GError *error,  gchar *debug);
		auto p = gst_message_new_error((src is null) ? null : src.getObjectGstStruct(), (error is null) ? null : error.getErrorGStruct(), Str.toStringz(dbug));

		if(p is null)
		{
			throw new ConstructionException("null returned by gst_message_new_error");
		}

		return new Message(cast(GstMessage*)p );
	}

	/**
	 * Create a new info message. The message will make copies of error and
	 * debug.
	 * MT safe.
	 * Since 0.10.12
	 * Params:
	 *  src = The object originating the message.
	 *  error = The GError for this message.
	 *  debug = A debugging string for something or other.
	 * Returns:
	 *  The new info message.
	 */
	public static Message newInfo(ObjectGst src, ErrorG error, string dbug)
	{
		// GstMessage* gst_message_new_info (GstObject *src,  GError *error,  gchar *debug);
		auto p = gst_message_new_info((src is null) ? null : src.getObjectGstStruct(), (error is null) ? null : error.getErrorGStruct(), Str.toStringz(dbug));

		if(p is null)
		{
			throw new ConstructionException("null returned by gst_message_new_info");
		}

		return new Message(cast(GstMessage*)p );
	}

	/**
	 * This message can be posted by elements when their latency requirements
	 * have changed.
	 * Params:
	 *     src = The object originating the message.
	 * Returns:
	 * The new latency message. MT safe.
	 */
	public static Message newLatency(ObjectGst src)
	{
		// GstMessage* gst_message_new_latency (GstObject *src);
		auto p = gst_message_new_latency((src is null) ? null : src.getObjectGstStruct());

		if(p is null)
		{
			throw new ConstructionException("null returned by gst_message_new_latency");
		}

		return new Message(cast(GstMessage*)p );
	}

	/**
	 * This message is posted by elements when they start an ASYNC state change.
	 * new_base_time is set to TRUE when the element lost its state when it was
	 * PLAYING.
	 * Params:
	 * src = The object originating the message.
	 * newBaseTime = if a new base_time should be set on the element
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public static Message newAsyncStart(ObjectGst src, int newBaseTime)
	{
		// GstMessage* gst_message_new_async_start (GstObject *src,  gboolean new_base_time);
		auto p = gst_message_new_async_start((src is null) ? null : src.getObjectGstStruct(), newBaseTime);

		if(p is null)
		{
			throw new ConstructionException("null returned by gst_message_new_async_start");
		}

		return new Message(cast(GstMessage*)p);
	}
code: end
outFile: Message

file: GstPadTemplate.html
struct: GstPadTemplate
class: PadTemplate
prefix: gst_pad_template_
prefix: gst_
import: glib.Str
import: gstreamer.Pad
import: gstreamer.Caps
structWrap: GstPadTemplate* PadTemplate
structWrap: GstPad* Pad
structWrap: GstCaps* Caps
outFile: PadTemplate

file: gstreamer-GstParse.html
class: Parse
prefix: gst_parse_
#I'm not so sure about the following:
nocode: gst_parse_error_quark
code: start
	/**
	 * Get the error quark used by the parsing subsystem.
	 * Returns:
	 *  the quark of the parse errors.
	 */
	public static Quark errorQuark()
	{
		// GQuark gst_parse_error_quark (void);
		return new Quark( cast(uint*)gst_parse_error_quark() );
	}
code: end
import: glib.Str
import: glib.Quark
import: glib.ErrorG
import: glib.GException
import: gstreamer.Element
structWrap: GQuark Quark
structWrap: GError* ErrorG
structWrap: GstElement* Element
outFile: Parse

file: GstPipeline.html
struct: GstPipeline
ctorStruct: GstElement
class: Pipeline
prefix: gst_pipeline_
prefix: gst_
override: getBus
override: setClock
override: getClock
import: glib.Str
import: gstreamer.Element
import: gstreamer.Clock
import: gstreamer.Bus
structWrap: GstPipeline* Pipeline
structWrap: GstElement* Element
structWrap: GstBus* Bus
structWrap: GstClock* Clock
outFile: Pipeline

file: GstPlugin.html
struct: GstPlugin
class: Plugin
prefix: gst_plugin_
prefix: gst_
override: getName
import: glib.Str
import: glib.Module
import: glib.ErrorG
import: glib.GException
import: glib.ListG
structWrap: GstPlugin* Plugin
structWrap: GModule* Module
structWrap: GList* ListG
outFile: Plugin

file: GstPluginFeature.html
struct: GstPluginFeature
class: PluginFeature
prefix: gst_plugin_feature_
prefix: gst_
override: getName
import: glib.Str
import: glib.ListG
structWrap: GstPluginFeature* PluginFeature
structWrap: GList* ListG
alias: setName setFeatureName
outFile: PluginFeature

file: gstreamer-GstQuery.html
struct: GstQuery
class: Query
prefix: gst_query_
prefix: gst_
import: glib.Str
import: gstreamer.Iterator
import: gstreamer.Structure
structWrap: GstIterator* Iterator
structWrap: GstQuery* Query
structWrap: GstStructure* Structure

inout: gst_query_parse_convert src_format
inout: gst_query_parse_convert src_value
inout: gst_query_parse_convert dest_format
inout: gst_query_parse_convert dest_value
inout: gst_query_parse_position format
inout: gst_query_parse_position cur
inout: gst_query_parse_duration format
inout: gst_query_parse_duration duration
inout: gst_query_parse_latency live
inout: gst_query_parse_latency min_latency
inout: gst_query_parse_latency max_latency
inout: gst_query_parse_seeking format
inout: gst_query_parse_seeking seekable
inout: gst_query_parse_seeking segment_start
inout: gst_query_parse_seeking segment_end
array: gst_query_set_formatsv formats n_formats
out: gst_query_parse_formats_length n_formats
out: gst_query_parse_formats_nth format
inout: gst_query_parse_segment rate
inout: gst_query_parse_segment format
inout: gst_query_parse_segment start_value
inout: gst_query_parse_segment stop_value

nocode: gst_query_new_position
code: start
	/**
	 * Constructs a new query stream position query object. Use gst_query_unref()
	 * when done with it. A position query is used to query the current position
	 * of playback in the streams, in some format.
	 * Params:
	 *  format = the default GstFormat for the new query
	 * Returns:
	 *  A GstQuery
	 */
	public static Query newPosition(GstFormat format)
	{
		// GstQuery* gst_query_new_position (GstFormat format);
		auto p = gst_query_new_position(format);

		if(p is null)
		{
			throw new ConstructionException("null returned by gst_query_new_position");
		}

		return new Query( cast(GstQuery*)p );
	}
code: end
nocode: gst_query_new_duration
code: start
	/**
	 * Constructs a new stream duration query object to query in the given format.
	 * Use gst_query_unref() when done with it. A duration query will give the
	 * total length of the stream.
	 * Params:
	 *  format = the GstFormat for this duration query
	 * Returns:
	 *  A GstQuery
	 */
	public static Query newDuration(GstFormat format)
	{
		// GstQuery* gst_query_new_duration (GstFormat format);
		auto p = gst_query_new_duration(format);

		if(p is null)
		{
			throw new ConstructionException("null returned by gst_query_new_duration");
		}

		return new Query( cast(GstQuery*)p );
	}
code: end
nocode: gst_query_new_seeking
code: start
	/**
	 * Constructs a new query object for querying seeking properties of
	 * the stream.
	 * Params:
	 *  format = the default GstFormat for the new query
	 * Returns:
	 *  A GstQuery
	 */
	public static Query newSeeking(GstFormat format)
	{
		// GstQuery* gst_query_new_seeking (GstFormat format);
		auto p = gst_query_new_seeking(format);

		if(p is null)
		{
			throw new ConstructionException("null returned by gst_query_new_seeking");
		}

		return new Query(cast(GstQuery*)p );
	}
code: end
nocode: gst_query_new_formats
code: start
	/**
	 * Constructs a new query object for querying formats of
	 * the stream.
	 * Since 0.10.4
	 * Returns:
	 *  A GstQuery
	 */
	public static Query newFormats()
	{
		// GstQuery* gst_query_new_formats (void);
		auto p = gst_query_new_formats();

		if(p is null)
		{
			throw new ConstructionException("null returned by gst_query_new_formats");
		}

		return new Query(cast(GstQuery*)p );
	}
code: end
nocode: gst_query_new_segment
code: start
	/**
	 * Constructs a new segment query object. Use gst_query_unref()
	 * when done with it. A segment query is used to discover information about the
	 * currently configured segment for playback.
	 * Params:
	 *  format = the GstFormat for the new query
	 * Returns:
	 *  a GstQuery
	 */
	public static Query newSegment(GstFormat format)
	{
		// GstQuery* gst_query_new_segment (GstFormat format);
		auto p = gst_query_new_segment(format);

		if(p is null)
		{
			throw new ConstructionException("null returned by gst_query_new_segment");
		}

		return new Query(cast(GstQuery*)p );
	}
code: end
outFile: Query

file: GstRegistry.html
struct: GstRegistry
class: Registry
prefix: gst_registry_
prefix: gst_
import: glib.Str
import: glib.ListG
import: gstreamer.Plugin
import: gstreamer.PluginFeature
#import: gobject.Type
#structWrap: GType Type
structWrap: GstRegistry* Registry
structWrap: GList* ListG
structWrap: GstPlugin* Plugin
structWrap: GstPluginFeature* PluginFeature
outFile: Registry

file: gstreamer-GstSegment.html
struct: GstSegment
class: Segment
prefix: gst_segment_
prefix: gst_
import: glib.Str
structWrap: GstSegment* Segment

inout: gst_segment_clip clip_start
inout: gst_segment_clip clip_stop
inout: gst_segment_set_seek update
outFile: Segment

file: gstreamer-GstStructure.html
struct: GstStructure
class: Structure
prefix: gst_structure_
prefix: gst_
import: glib.Str
import: glib.Date
import: gobject.Value
structWrap: GstStructure* Structure
structWrap: GDate* Date
structWrap: GValue* Value

override: toString
out: gst_structure_get_boolean value
out: gst_structure_get_int value
out: gst_structure_get_fourcc value
out: gst_structure_get_double value
out: gst_structure_get_date value
out: gst_structure_get_clock_time value
out: gst_structure_get_enum value
out: gst_structure_get_fraction value_numerator
out: gst_structure_get_fraction value_denominator
out: gst_structure_from_string end
outFile: Structure

file: GstSystemClock.html
struct: GstSystemClock
class: SystemClock
prefix: gst_system_clock_
import: glib.Str
import: gstreamer.Clock
structWrap: GstSystemClock* SystemClock
structWrap: GstClock* Clock
outFile: SystemClock

file: gstreamer-GstTagList.html
struct: GstTagList
class: TagList
prefix: gst_tag_list_
prefix: gst_tag_
import: glib.Str
import: glib.Date
import: gobject.Value
structWrap: GDate* Date
structWrap: GValue* Value
structWrap: GstTagList* TagList

inout: gst_tag_list_get_uchar value
inout: gst_tag_list_get_uchar_index value
inout: gst_tag_list_get_boolean value
inout: gst_tag_list_get_boolean_index value
inout: gst_tag_list_get_int value
inout: gst_tag_list_get_int_index value
inout: gst_tag_list_get_uint value
inout: gst_tag_list_get_uint_index value
inout: gst_tag_list_get_long value
inout: gst_tag_list_get_long_index value
inout: gst_tag_list_get_ulong value
inout: gst_tag_list_get_ulong_index value
inout: gst_tag_list_get_int64 value
inout: gst_tag_list_get_int64_index value
inout: gst_tag_list_get_uint64 value
inout: gst_tag_list_get_uint64_index value
inout: gst_tag_list_get_float value
inout: gst_tag_list_get_float_index value
inout: gst_tag_list_get_double value
inout: gst_tag_list_get_double_index value
inout: gst_tag_list_get_string value
inout: gst_tag_list_get_string_index value
inout: gst_tag_list_get_date value
inout: gst_tag_list_get_date_index value
outFile: TagList

file: GstTagSetter.html
struct: GstTagSetter
class: TagSetter
prefix: gst_tag_setter_
prefix: gst_
import: glib.Str
import: gstreamer.TagList
structWrap: GstTagSetter* TagSetter
structWrap: GstTagList* TagList
outFile: TagSetter

file: GstTask.html
struct: GstTask
class: Task
prefix: gst_task_
prefix: gst_
import: glib.Str
structWrap: GstTask* Task
outFile: Task

file: gstreamer-GstTypeFind.html
struct: GstTypeFind
class: TypeFind
prefix: gst_type_find_
prefix: gst_
import: glib.Str
import: gstreamer.Caps
import: gstreamer.Plugin
structWrap: GstTypeFind* TypeFind
structWrap: GstCaps* Caps
structWrap: GstPlugin* Plugin
array: gst_type_find_register extensions
nocode: gst_type_find_peek
code: start
	/**
	 * Returns the size bytes of the stream to identify beginning at offset. If
	 * offset is a positive number, the offset is relative to the beginning of the
	 * stream, if offset is a negative number the offset is relative to the end of
	 * the stream. The returned memory is valid until the typefinding function
	 * returns and must not be freed.
	 * Params:
	 * offset = The offset
	 * size = The number of bytes to return
	 * Returns: the requested data, or NULL if that data is not available.
	 */
	public ubyte[] peek(long offset, uint size)
	{
		// guint8* gst_type_find_peek (GstTypeFind *find,  gint64 offset,  guint size);
		ubyte* buff = gst_type_find_peek(gstTypeFind, offset, size);

		return buff[0 .. size];
	}
code: end
outFile: TypeFind

file: GstTypeFindFactory.html
struct: GstTypeFindFactory
class: TypeFindFactory
prefix: gst_type_find_factory_
prefix: gst_
import: glib.Str
import: glib.ListG
import: gstreamer.TypeFind
import: gstreamer.Caps
structWrap: GstTypeFindFactory* TypeFindFactory
structWrap: GList* ListG
structWrap: GstTypeFind* TypeFind
structWrap: GstCaps* Caps
outFile: TypeFindFactory

#libxml2 missing:
#file: GstXML.html
#struct: GstXML
#class: XML
#prefix: gst_xml_
#prefix: gst_
#structWrap: GstXML* XML
#structWrap: GstElement* Element
#outFile: XML

